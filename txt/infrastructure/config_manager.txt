#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Config Manager - EAS H√≠brido 2025 Unified Configuration
Hot reload with hierarchical configs, legacy migration, and validation.
Optimized for production trading environment.
"""

import json
import time
import logging
import threading
from pathlib import Path
from typing import Dict, Any, Callable, Optional, List, Tuple
from datetime import datetime
from enum import Enum
import asyncio
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from jsonschema import validate, ValidationError
from prometheus_client import Counter, Gauge

logger = logging.getLogger("HECTAGold.ConfigManager")

# Prometheus metrics
CONFIG_RELOADS = Counter('config_reloads_total', 'Total config reloads', ['status'])
CONFIG_VALIDATIONS = Counter('config_validations_total', 'Config validations', ['result'])
CONFIG_VALUE_CHANGES = Counter('config_value_changes', 'Config value changes', ['section'])

class ConfigType(Enum):
    TRADING = "trading_config"
    AGENTS = "agents_config" 
    RISK = "risk_config"
    LEGACY = "legacy"

class ConfigChangeHandler(FileSystemEventHandler):
    """Handler optimizado para hot-reload en producci√≥n"""
    
    def __init__(self, config_manager: 'ConfigManager'):
        self.config_manager = config_manager
        self.debounce_timers: Dict[str, threading.Timer] = {}
        self.debounce_delay = 2.0  # 2 segundos para evitar m√∫ltiples reloads
        
    def on_modified(self, event):
        """Maneja cambios de archivo con debounce"""
        if event.is_directory or not event.src_path.endswith('.json'):
            return
            
        config_file = Path(event.src_path).name
        
        # Cancelar timer existente para este archivo
        if config_file in self.debounce_timers:
            self.debounce_timers[config_file].cancel()
            
        # Programar nuevo reload con debounce
        timer = threading.Timer(self.debounce_delay, self._handle_config_change, args=[event.src_path, config_file])
        self.debounce_timers[config_file] = timer
        timer.start()
    
    def _handle_config_change(self, file_path: str, config_file: str):
        """Ejecuta reload despu√©s del per√≠odo de debounce"""
        try:
            logger.info(f"üîÑ Config change detected: {config_file}")
            self.config_manager.reload_config_file(file_path)
            
            # Limpiar timer
            if config_file in self.debounce_timers:
                del self.debounce_timers[config_file]
                
        except Exception as e:
            logger.error(f"‚ùå Config reload error: {e}")
            CONFIG_RELOADS.labels(status='error').inc()

class ConfigManager:
    """
    Gestor de configuraci√≥n unificada EAS H√≠brido 2025
    Soporte para configuraci√≥n jer√°rquica con migraci√≥n desde legacy
    """
    
    def __init__(self, config_base_path: Path, enable_hot_reload: bool = True):
        self.config_base_path = Path(config_base_path)
        self.enable_hot_reload = enable_hot_reload
        
        # CONFIGURACI√ìN JER√ÅRQUICA
        self.configs: Dict[ConfigType, Dict[str, Any]] = {
            ConfigType.TRADING: {},
            ConfigType.AGENTS: {},
            ConfigType.RISK: {}
        }
        
        # ARCHIVOS LEGACY PARA MIGRACI√ìN
        self.legacy_configs: Dict[str, Dict[str, Any]] = {}
        
        # ESQUEMAS DE VALIDACI√ìN
        self.validation_schemas: Dict[ConfigType, Dict[str, Any]] = {}
        
        # GESTI√ìN DE ESTADO
        self.last_reload_time: Optional[datetime] = None
        self.reload_count = 0
        self.config_lock = threading.RLock()
        
        # CALLBACKS PARA ORCHESTRATOR
        self.callbacks: List[Callable[[ConfigType, Dict[str, Any]], None]] = []
        
        # WATCHER PARA HOT RELOAD
        self.observer = Observer() if enable_hot_reload else None
        self.change_handler = ConfigChangeHandler(self) if enable_hot_reload else None
        
        # M√âTRICAS
        self.stats = {
            'total_reloads': 0,
            'successful_reloads': 0, 
            'failed_reloads': 0,
            'validation_errors': 0,
            'callback_errors': 0
        }
        
        # MAPPING LEGACY ‚Üí NUEVA CONFIGURACI√ìN
        self.legacy_mapping = self._build_legacy_mapping()
        
        logger.info("‚öôÔ∏è ConfigManager EAS H√≠brido 2025 inicializado")

    def _build_legacy_mapping(self) -> Dict[str, Tuple[ConfigType, str]]:
        """Construye mapeo de configuraciones legacy a nueva estructura"""
        return {
            # ea_settings.json ‚Üí trading_config.json
            ('ea_settings', 'risk_percent'): (ConfigType.TRADING, 'core_trading.risk_management.fixed_risk.risk_per_trade'),
            ('ea_settings', 'max_daily_risk'): (ConfigType.TRADING, 'core_trading.risk_management.fixed_risk.max_daily_risk'),
            ('ea_settings', 'consecutive_loss_limit'): (ConfigType.TRADING, 'core_trading.risk_management.safety_limits.consecutive_losses_limit'),
            
            # hecta_gold_config.json ‚Üí trading_config.json  
            ('hecta_gold', 'session', 'ny_open_start'): (ConfigType.TRADING, 'core_trading.session_settings.ny_core_session.start_time'),
            ('hecta_gold', 'session', 'london_ny_overlap_start'): (ConfigType.TRADING, 'core_trading.session_settings.london_ny_overlap.start_time'),
            ('hecta_gold', 'trading', 'max_trades'): (ConfigType.TRADING, 'core_trading.entry_rules.max_entries_per_session'),
            
            # hecta_gold_config.json ‚Üí agents_config.json
            ('hecta_gold', 'ia', 'temperature'): (ConfigType.AGENTS, 'signal_validation_agent.temperature'),
            ('hecta_gold', 'ia', 'max_tokens'): (ConfigType.AGENTS, 'signal_validation_agent.max_tokens'),
        }

    async def initialize(self):
        """Inicializaci√≥n as√≠ncrona completa"""
        try:
            # 1. Cargar configuraciones principales
            await self._load_all_configs()
            
            # 2. Cargar configuraciones legacy para migraci√≥n
            await self._load_legacy_configs()
            
            # 3. Inicializar esquemas de validaci√≥n
            await self._initialize_validation_schemas()
            
            # 4. Iniciar hot-reload si est√° habilitado
            if self.enable_hot_reload and self.observer:
                self.observer.schedule(
                    self.change_handler, 
                    str(self.config_base_path), 
                    recursive=True
                )
                self.observer.start()
                logger.info("üëÄ Hot-reload habilitado para configuraci√≥n")
            
            # 5. Validar configuraci√≥n completa
            validation_result = await self._validate_all_configs()
            if not validation_result:
                logger.error("‚ùå Validaci√≥n de configuraci√≥n fall√≥")
                raise ValueError("Configuraci√≥n inv√°lida")
                
            logger.info("‚úÖ ConfigManager inicializado exitosamente")
            
        except Exception as e:
            logger.error(f"‚ùå Error inicializando ConfigManager: {e}")
            raise

    async def _load_all_configs(self):
        """Carga todas las configuraciones principales"""
        config_files = {
            ConfigType.TRADING: "trading_config.json",
            ConfigType.AGENTS: "agents_config.json", 
            ConfigType.RISK: "risk_config.json"
        }
        
        for config_type, filename in config_files.items():
            file_path = self.config_base_path / filename
            await self._load_single_config(config_type, file_path)

    async def _load_single_config(self, config_type: ConfigType, file_path: Path):
        """Carga una configuraci√≥n individual"""
        try:
            if file_path.exists():
                with open(file_path, 'r', encoding='utf-8') as f:
                    config_data = json.load(f)
                
                self.configs[config_type] = config_data
                logger.info(f"‚úÖ Config loaded: {config_type.value}")
                
            else:
                logger.warning(f"‚ö†Ô∏è Config file not found: {file_path}")
                self.configs[config_type] = {}
                
        except Exception as e:
            logger.error(f"‚ùå Error loading {config_type.value}: {e}")
            self.configs[config_type] = {}

    async def _load_legacy_configs(self):
        """Carga configuraciones legacy para compatibilidad"""
        legacy_files = {
            'ea_settings': 'legacy/ea_settings.json',
            'hecta_gold': 'legacy/hecta_gold_config.json'
        }
        
        for name, filename in legacy_files.items():
            file_path = self.config_base_path / filename
            if file_path.exists():
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        self.legacy_configs[name] = json.load(f)
                    logger.info(f"üìÅ Legacy config loaded: {name}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Error loading legacy config {name}: {e}")
            else:
                logger.debug(f"üìÅ Legacy config not found: {name}")

    async def _initialize_validation_schemas(self):
        """Inicializa esquemas de validaci√≥n JSON"""
        # Esquema b√°sico para trading config
        self.validation_schemas[ConfigType.TRADING] = {
            "type": "object",
            "required": ["core_trading", "risk_management"],
            "properties": {
                "core_trading": {
                    "type": "object",
                    "required": ["instrument", "session_settings", "risk_management"],
                    "properties": {
                        "instrument": {"type": "string", "const": "XAUUSD"},
                        "risk_management": {
                            "type": "object",
                            "required": ["fixed_risk"],
                            "properties": {
                                "fixed_risk": {
                                    "type": "object", 
                                    "required": ["risk_per_trade", "max_daily_risk"],
                                    "properties": {
                                        "risk_per_trade": {"type": "number", "minimum": 0.1, "maximum": 1.0},
                                        "max_daily_risk": {"type": "number", "minimum": 0.5, "maximum": 5.0}
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        logger.info("‚úÖ Validation schemas initialized")

    async def _validate_all_configs(self) -> bool:
        """Valida todas las configuraciones"""
        all_valid = True
        
        for config_type, config_data in self.configs.items():
            if config_type in self.validation_schemas:
                try:
                    validate(instance=config_data, schema=self.validation_schemas[config_type])
                    CONFIG_VALIDATIONS.labels(result='success').inc()
                    logger.debug(f"‚úÖ Config validation passed: {config_type.value}")
                except ValidationError as e:
                    logger.error(f"‚ùå Config validation failed for {config_type.value}: {e}")
                    CONFIG_VALIDATIONS.labels(result='error').inc()
                    all_valid = False
                    
        return all_valid

    def get_config(self, key_path: str, use_legacy_fallback: bool = True) -> Any:
        """
        Obtiene valor de configuraci√≥n con fallback a legacy
        
        Args:
            key_path: Ruta en formato "config_type.section.subsection.key"
            use_legacy_fallback: Si permite fallback a configuraciones legacy
            
        Returns:
            Valor de configuraci√≥n o None si no existe
        """
        with self.config_lock:
            try:
                # Parsear ruta (ej: "trading.core_trading.instrument")
                parts = key_path.split('.')
                if len(parts) < 2:
                    raise ValueError(f"Invalid config path: {key_path}")
                    
                config_type_str, *path_parts = parts
                
                # Determinar tipo de configuraci√≥n
                try:
                    config_type = ConfigType(config_type_str)
                except ValueError:
                    raise ValueError(f"Unknown config type: {config_type_str}")
                
                # Navegar por la configuraci√≥n
                current = self.configs[config_type]
                for part in path_parts:
                    if isinstance(current, dict) and part in current:
                        current = current[part]
                    else:
                        current = None
                        break
                
                # Si encontramos valor, retornarlo
                if current is not None:
                    return current
                    
                # FALLBACK A LEGACY SI EST√Å HABILITADO
                if use_legacy_fallback and self.legacy_configs:
                    legacy_value = self._get_from_legacy(key_path)
                    if legacy_value is not None:
                        logger.debug(f"üîÑ Using legacy value for: {key_path}")
                        return legacy_value
                
                logger.warning(f"‚ö†Ô∏è Config value not found: {key_path}")
                return None
                
            except Exception as e:
                logger.error(f"‚ùå Error getting config {key_path}: {e}")
                return None

    def _get_from_legacy(self, key_path: str) -> Any:
        """Intenta obtener valor desde configuraciones legacy"""
        # Buscar en mapeo legacy
        for (legacy_file, legacy_key), (config_type, new_path) in self.legacy_mapping.items():
            if key_path == new_path:
                legacy_config = self.legacy_configs.get(legacy_file, {})
                
                # Navegar por estructura legacy
                if legacy_key in legacy_config:
                    return legacy_config[legacy_key]
                elif isinstance(legacy_key, tuple) and len(legacy_key) == 2:
                    # Estructura anidada legacy
                    section, key = legacy_key
                    if section in legacy_config and key in legacy_config[section]:
                        return legacy_config[section][key]
        
        return None

    def set_config(self, key_path: str, value: Any) -> bool:
        """
        Establece valor de configuraci√≥n (para testing/dynamic adjustment)
        
        Note: No persiste en archivo, solo en memoria
        """
        with self.config_lock:
            try:
                parts = key_path.split('.')
                if len(parts) < 2:
                    return False
                    
                config_type_str, *path_parts = parts
                config_type = ConfigType(config_type_str)
                
                # Navegar hasta el padre del valor final
                current = self.configs[config_type]
                for part in path_parts[:-1]:
                    if part not in current:
                        current[part] = {}
                    current = current[part]
                
                # Establecer valor
                final_key = path_parts[-1]
                current[final_key] = value
                
                CONFIG_VALUE_CHANGES.labels(section=config_type.value).inc()
                logger.info(f"‚úèÔ∏è Config updated: {key_path} = {value}")
                
                # Notificar callbacks
                self._notify_callbacks(config_type, self.configs[config_type])
                
                return True
                
            except Exception as e:
                logger.error(f"‚ùå Error setting config {key_path}: {e}")
                return False

    def reload_config_file(self, file_path: str) -> bool:
        """Recarga archivo de configuraci√≥n espec√≠fico"""
        file_path = Path(file_path)
        config_file = file_path.name
        
        try:
            with self.config_lock:
                self.stats['total_reloads'] += 1
                
                # Determinar tipo de configuraci√≥n basado en nombre de archivo
                config_type = None
                if config_file == "trading_config.json":
                    config_type = ConfigType.TRADING
                elif config_file == "agents_config.json":
                    config_type = ConfigType.AGENTS
                elif config_file == "risk_config.json":
                    config_type = ConfigType.RISK
                else:
                    logger.warning(f"‚ö†Ô∏è Unknown config file: {config_file}")
                    return False
                
                # Cargar nuevo contenido
                with open(file_path, 'r', encoding='utf-8') as f:
                    new_config = json.load(f)
                
                # Validar
                if config_type in self.validation_schemas:
                    validate(instance=new_config, schema=self.validation_schemas[config_type])
                
                # Actualizar configuraci√≥n
                self.configs[config_type] = new_config
                self.last_reload_time = datetime.now()
                self.reload_count += 1
                self.stats['successful_reloads'] += 1
                
                # Notificar callbacks
                self._notify_callbacks(config_type, new_config)
                
                CONFIG_RELOADS.labels(status='success').inc()
                logger.info(f"üîÑ Config reloaded: {config_file}")
                return True
                
        except Exception as e:
            self.stats['failed_reloads'] += 1
            CONFIG_RELOADS.labels(status='error').inc()
            logger.error(f"‚ùå Config reload failed for {config_file}: {e}")
            return False

    def register_callback(self, callback: Callable[[ConfigType, Dict[str, Any]], None]):
        """Registra callback para cambios de configuraci√≥n"""
        self.callbacks.append(callback)
        logger.info(f"üìù Callback registered: {callback.__name__}")

    def _notify_callbacks(self, config_type: ConfigType, new_config: Dict[str, Any]):
        """Notifica a todos los callbacks registrados"""
        for callback in self.callbacks:
            try:
                callback(config_type, new_config)
            except Exception as e:
                self.stats['callback_errors'] += 1
                logger.error(f"‚ùå Config callback error: {e}")

    async def save_config(self, config_type: ConfigType) -> bool:
        """Guarda configuraci√≥n a archivo"""
        try:
            filename = f"{config_type.value}.json"
            file_path = self.config_base_path / filename
            
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(self.configs[config_type], f, indent=2, ensure_ascii=False)
            
            logger.info(f"üíæ Config saved: {filename}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error saving config {config_type.value}: {e}")
            return False

    def get_detailed_status(self) -> Dict[str, Any]:
        """Estado detallado del config manager"""
        with self.config_lock:
            status = {
                'timestamp': datetime.now().isoformat(),
                'configs_loaded': {
                    config_type.value: len(config_data) > 0 
                    for config_type, config_data in self.configs.items()
                },
                'legacy_configs_loaded': list(self.legacy_configs.keys()),
                'last_reload_time': self.last_reload_time.isoformat() if self.last_reload_time else None,
                'total_reloads': self.reload_count,
                'callbacks_registered': len(self.callbacks),
                'hot_reload_enabled': self.enable_hot_reload,
                'validation_schemas': list(self.validation_schemas.keys()),
                'stats': self.stats.copy()
            }
            
            # Calcular tasa de √©xito
            total_reloads = self.stats['total_reloads']
            if total_reloads > 0:
                status['stats']['success_rate'] = (self.stats['successful_reloads'] / total_reloads) * 100
            else:
                status['stats']['success_rate'] = 100.0
                
            return status

    def force_reload_all(self) -> bool:
        """Fuerza recarga de todas las configuraciones"""
        logger.info("üîÑ Forcing reload of all configs")
        try:
            asyncio.create_task(self._load_all_configs())
            return True
        except Exception as e:
            logger.error(f"‚ùå Force reload failed: {e}")
            return False

    async def close(self):
        """Cierre seguro del config manager"""
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("üîå ConfigManager closed")

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        asyncio.run(self.close())

# Decorator para inyecci√≥n de configuraci√≥n
def with_config(config_path: str):
    """
    Decorator para inyectar valores de configuraci√≥n en funciones
    
    Usage:
        @with_config("trading.core_trading.instrument")
        def some_function(..., config_value=None):
            # config_value contiene el valor de la configuraci√≥n
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            config_manager = kwargs.pop('config_manager', None)
            if not config_manager:
                raise ValueError("ConfigManager instance required")
                
            config_value = config_manager.get_config(config_path)
            kwargs['config_value'] = config_value
            return func(*args, **kwargs)
        return wrapper
    return decorator

# Singleton global para acceso f√°cil
_config_manager_instance: Optional[ConfigManager] = None

def get_config_manager() -> ConfigManager:
    """Obtiene instancia singleton del ConfigManager"""
    global _config_manager_instance
    if _config_manager_instance is None:
        raise RuntimeError("ConfigManager not initialized. Call initialize_config_manager() first.")
    return _config_manager_instance

async def initialize_config_manager(config_path: Path, enable_hot_reload: bool = True) -> ConfigManager:
    """Inicializa el ConfigManager singleton"""
    global _config_manager_instance
    if _config_manager_instance is None:
        _config_manager_instance = ConfigManager(config_path, enable_hot_reload)
        await _config_manager_instance.initialize()
    return _config_manager_instance